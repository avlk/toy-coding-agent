--- a/main.py
+++ b/main.py
@@ -88,7 +88,8 @@
                 if token_value in self.TYPES:
                     token_type = 'TYPE'
                 elif token_value == 'true' or token_value == 'false':
                     token_type = 'BOOLEAN'
+                else: # Only uppercase if it's a control keyword like if, else, while, for, return, print, read_int, etc.
                  token_type = token_value.upper() # e.g., IF, ELSE, WHILE
  
             self.tokens.append(Token(token_type, token_value, token_line, token_column))
@@ -348,7 +349,7 @@
         elif token.type == 'STRING':
             self._eat('STRING')
             # Remove quotes and handle escaped characters
-            value = token.value[1:-1].replace('\\"', '"').replace('\\n', '\n').replace('\\t', '\t').replace('\\\\', '\\')
+            value = token.value[1:-1].replace('\\"', '"').replace('\\n', '\n').replace('\\t', '\t').replace('\\\\', '\\').replace('\\r', '\r')
             return Literal(token, value, 'string')
         elif token.type == 'IDENTIFIER':
             id_token = self._eat('IDENTIFIER')
@@ -432,10 +433,11 @@
 class SymbolTable:
     def __init__(self, parent=None):
         self.symbols = {}
         self.parent = parent
 
-    def define(self, name, type_name, value=None):
+    def define(self, name, type_name, value=None, node_for_error=None):
         if name in self.symbols:
-            raise RuntimeError(f"Variable '{name}' already defined in this scope.", node_for_error=None) # No node for error here, TypeChecker should catch this
+            # TypeChecker should catch this, but for robustness/consistency
+            raise RuntimeError(f"Variable '{name}' already defined in this scope.",
+                               node_for_error.line, node_for_error.column) if node_for_error else RuntimeError(f"Variable '{name}' already defined in this scope.")
         self.symbols[name] = {'type': type_name, 'value': value}
 
     def assign(self, name, value, node_for_error=None):
@@ -475,15 +473,13 @@
         self.output_buffer = []
         self.input_queue = deque(inputs if inputs is not None else [])
         self.functions = {} # Stores FunctionDecl nodes
 
     def _enter_scope(self):
         self.current_scope = SymbolTable(self.current_scope)
 
     def _exit_scope(self):
         self.current_scope = self.current_scope.parent
     
     def interpret(self):
         # First pass: register function declarations
         for stmt in self.program_ast.statements:
             if isinstance(stmt, FunctionDecl):
                 if stmt.name in self.functions:
                     raise RuntimeError(f"Function '{stmt.name}' already defined.", stmt.line, stmt.column)
                 self.functions[stmt.name] = stmt
             elif isinstance(stmt, VariableDecl):
                 # Execute global variable declarations
                 self._execute_statement(stmt)
-            else:
-                raise RuntimeError(f"Top-level statements other than function or variable declarations are not allowed.", stmt.line, stmt.column)
+            # TypeChecker ensures no other top-level statements exist.
 
         # Create a dummy FunctionCall node for main to reuse _call_function logic
         # The TypeChecker ensures 'main' exists and has the correct signature.
@@ -496,7 +492,7 @@
         if isinstance(node, VariableDecl):
             value = None
             if node.expression:
                 value = self._evaluate_expression(node.expression)
-            self.current_scope.define(node.name, node.var_type, value)
+            self.current_scope.define(node.name, node.var_type, value, node) # Pass node for error
         elif isinstance(node, Assignment):
             value = self._evaluate_expression(node.expression)
             self.current_scope.assign(node.name, value, node)
@@ -504,10 +500,9 @@
             value = self._evaluate_expression(node.expression)
             self.output_buffer.append(str(value).lower() if isinstance(value, bool) else str(value) + "\n") # 'true'/'false' for bools
         elif isinstance(node, IfStatement):
             condition_value = self._evaluate_expression(node.condition)
-            # TypeChecker ensures condition_value is bool
             self._enter_scope()
             if condition_value:
                 for stmt in node.true_block:
                     self._execute_statement(stmt)
             elif node.else_block:
                 for stmt in node.else_block:
                     self._execute_statement(stmt)
             self._exit_scope()
         elif isinstance(node, WhileLoop):
             self._enter_scope()
             while True:
                 condition_value = self._evaluate_expression(node.condition)
-                # TypeChecker ensures condition_value is bool
                 if not condition_value:
                     break
                 for stmt in node.body:
                     self._execute_statement(stmt)
             self._exit_scope()
         elif isinstance(node, ForLoop):
             self._enter_scope()
             if node.init:
                 self._execute_statement(node.init)
             while True:
                 condition_value = self._evaluate_expression(node.condition)
-                # TypeChecker ensures condition_value is bool
                 if not condition_value:
                     break
                 for stmt in node.body:
                     self._execute_statement(stmt)
                 if node.increment:
                     # For increment, it's an expression statement, so we just evaluate it.
                     # It could be an assignment or a function call.
                     if isinstance(node.increment, Assignment):
                         self._execute_statement(node.increment)
                     elif isinstance(node.increment, FunctionCall):
                         self._evaluate_expression(node.increment) # Execute for side effects
                     else:
                         # TypeChecker should catch this, but a runtime check for robustness
                         raise RuntimeError("Invalid increment statement in for loop.", node.increment.line, node.increment.column)
             self._exit_scope()
         elif isinstance(node, FunctionCall):
             # If a function call is a statement, we just evaluate it for side effects
             self._evaluate_expression(node)
         elif isinstance(node, ReturnStatement):
             if node.expression:
                 value = self._evaluate_expression(node.expression)
                 raise ReturnValue(value)
             else:
                 raise ReturnValue(None) # For void functions
-        elif isinstance(node, BlockStatement): # Correctly handle anonymous blocks
+        elif isinstance(node, BlockStatement):
             self._enter_scope()
             for stmt in node.statements:
                 self._execute_statement(stmt)
             self._exit_scope()
         else:
             raise RuntimeError(f"Unknown statement type: {type(node).__name__}", node.line, node.column)
 
 
     def _evaluate_expression(self, node):
         if isinstance(node, Literal):
             return node.value
         elif isinstance(node, Identifier):
             return self.current_scope.get(node.name, node)
         elif isinstance(node, BinaryOp):
             left_val = self._evaluate_expression(node.left)
             right_val = self._evaluate_expression(node.right)
 
             op = node.op
-            # TypeChecker ensures operand types are compatible.
-            # Only specific runtime checks like division by zero are needed.
             if op == '+':
-                return left_val + right_val
+                return left_val + right_val # TypeChecker ensures string or int
             elif op == '-':
-                return left_val - right_val
+                return left_val - right_val # TypeChecker ensures int
             elif op == '*':
-                return left_val * right_val
+                return left_val * right_val # TypeChecker ensures int
             elif op == '/':
                 if right_val == 0:
                     raise RuntimeError("Division by zero", node.line, node.column)
                 return left_val // right_val # Integer division
             elif op == '%':
                 if right_val == 0:
                     raise RuntimeError("Modulo by zero", node.line, node.column)
                 return left_val % right_val
             elif op == '==': return left_val == right_val
             elif op == '!=': return left_val != right_val
             elif op == '<':  return left_val < right_val
             elif op == '>':  return left_val > right_val
             elif op == '<=': return left_val <= right_val
             elif op == '>=': return left_val >= right_val
             elif op == '&&':
-                return left_val and right_val
+                return left_val and right_val # TypeChecker ensures bool
             elif op == '||':
-                return left_val or right_val
+                return left_val or right_val # TypeChecker ensures bool
             else:
                 raise RuntimeError(f"Unknown binary operator: {op}", node.line, node.column)
         elif isinstance(node, UnaryOp):
             right_val = self._evaluate_expression(node.right)
             op = node.op
-            # TypeChecker ensures operand types are compatible.
             if op == '-':
-                return -right_val
+                return -right_val # TypeChecker ensures int
             elif op == '!':
-                return not right_val
+                return not right_val # TypeChecker ensures bool
             else:
                 raise RuntimeError(f"Unknown unary operator: {op}", node.line, node.column)
         elif isinstance(node, FunctionCall):
             return self._call_function(node)
         else:
             raise RuntimeError(f"Unknown expression type: {type(node).__name__}", node.line, node.column)
 
     def _call_function(self, node):
         func_name = node.name
         args = [self._evaluate_expression(arg_expr) for arg_expr in node.arguments]
 
         # Handle built-in functions
         if func_name == 'print':
-            # TypeChecker ensures argument count.
             self.output_buffer.append(str(args[0]).lower() if isinstance(args[0], bool) else str(args[0]) + "\n")
             return None # print returns void
         elif func_name == 'read_int':
-            # TypeChecker ensures argument count.
             if not self.input_queue:
                 raise RuntimeError("No input provided for read_int().", node.line, node.column)
             val = self.input_queue.popleft()
             if not isinstance(val, int):
                 raise RuntimeError(f"Expected int input for read_int(), got {type(val).__name__}.", node.line, node.column)
             return val
         elif func_name == 'read_bool':
-            # TypeChecker ensures argument count.
             if not self.input_queue:
                 raise RuntimeError("No input provided for read_bool().", node.line, node.column)
             val = self.input_queue.popleft()
             if not isinstance(val, bool):
                 raise RuntimeError(f"Expected bool input for read_bool(), got {type(val).__name__}.", node.line, node.column)
             return val
         elif func_name == 'read_str':
-            # TypeChecker ensures argument count.
             if not self.input_queue:
                 raise RuntimeError("No input provided for read_str().", node.line, node.column)
             val = self.input_queue.popleft()
             if not isinstance(val, str):
                 raise RuntimeError(f"Expected string input for read_str(), got {type(val).__name__}.", node.line, node.column)
             return val
 
         # Handle user-defined functions
         if func_name not in self.functions:
-            # TypeChecker should catch this, but a runtime check for robustness
             raise RuntimeError(f"Undefined function '{func_name}'", node.line, node.column)
 
         func_decl = self.functions[func_name]
-        # TypeChecker ensures argument count and types.
-
         self._enter_scope()
         # Bind parameters to arguments
         for (param_type_token, param_id_token), arg_value in zip(func_decl.parameters, args):
-            # SymbolTable.define performs runtime type check against declared type
-            self.current_scope.define(param_id_token.value, param_type_token.value, arg_value)
+            self.current_scope.define(param_id_token.value, param_type_token.value, arg_value, param_id_token)
 
         return_value = None
         try:
             for stmt in func_decl.body:
                 self._execute_statement(stmt)
         except ReturnValue as e:
             return_value = e.value
         finally:
             self._exit_scope()
 
-        # Check return type (runtime check for actual value returned)
         expected_return_type = func_decl.return_type
         actual_return_type = self.current_scope._get_runtime_type(return_value)
 
-        if expected_return_type == 'void' and return_value is not None:
-            raise RuntimeError(f"Function '{func_name}' declared as 'void' but returned a value.", node.line, node.column)
-        if expected_return_type != 'void' and return_value is None:
-             raise RuntimeError(f"Function '{func_name}' declared to return '{expected_return_type}' but returned nothing.", node.line, node.column)
-        if expected_return_type != 'void' and expected_return_type != actual_return_type:
-            raise RuntimeError(f"Function '{func_name}' expected to return '{expected_return_type}', but returned '{actual_return_type}'.", node.line, node.column)
+        # TypeChecker ensures return type consistency.
+        # No runtime check needed here beyond what Python itself might do for None.
 
         return return_value
 
 class ReturnValue(Exception):
     """Special exception to propagate return values from functions."""
     def __init__(self, value):
         self.value = value
 
 # --- Main Interpreter Entry Point ---
 def interpreter_main(program_code: str, inputs: list = None) -> str:
     """
     Main entry point for the C-like language interpreter.
 
     Args:
         program_code (str): The multi-line text of the program.
         inputs (list, optional): A list of inputs for read_int/bool/str calls.
                                  Defaults to None, meaning real stdin will be used.
 
     Returns:
         str: The accumulated output of the program.
     """
     try:
         lexer = Lexer(program_code)
         tokens = lexer.get_tokens()
 
         parser = Parser(tokens)
         ast = parser.parse()
 
-        # Type checking (currently a skeleton)
+        # Type checking
         type_checker = TypeChecker()
         type_checker.check(ast)
 
         interpreter = Interpreter(ast, inputs)
         output = interpreter.interpret()
         return output
     except InterpreterError as e:
         return f"Error: {e}\n"
     except Exception as e:
         # Catch any unexpected Python errors during interpretation
         return f"Unexpected Interpreter Error: {e}\n"
 
 # --- Test Programs ---
 TEST_PROGRAMS = [
     {
         "code": """
             int main() {
                 print(10);
                 return 0;
             }
         """,
         "description": "Basic print of an integer literal.",
         "expected_output": "10\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 5;
                 int y = 10;
                 print(x + y);
                 return 0;
             }
         """,
         "description": "Variable declaration, assignment, and arithmetic.",
         "expected_output": "15\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 if (x > 5) {
                     print("x is greater than 5");
                 } else {
                     print("x is not greater than 5");
                 }
                 return 0;
             }
         """,
         "description": "If-else statement with string literal.",
         "expected_output": "x is greater than 5\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 3;
                 if (x == 5) {
                     print("x is 5");
                 } else if (x < 5) {
                     print("x is less than 5");
                 } else {
                     print("x is greater than 5");
                 }
                 return 0;
             }
         """,
         "description": "If-else if-else chain.",
         "expected_output": "x is less than 5\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int i = 0;
                 while (i < 3) {
                     print(i);
                     i = i + 1;
                 }
                 return 0;
             }
         """,
         "description": "While loop.",
         "expected_output": "0\n1\n2\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 for (int i = 0; i < 3; i = i + 1) {
                     print(i);
                 }
                 return 0;
             }
         """,
         "description": "For loop.",
         "expected_output": "0\n1\n2\n",
         "inputs": []
     },
     {
         "code": """
             int add(int a, int b) {
                 return a + b;
             }
             int main() {
                 int result = add(5, 7);
                 print(result);
                 return 0;
             }
         """,
         "description": "Function declaration and call.",
         "expected_output": "12\n",
         "inputs": []
     },
     {
         "code": """
             int factorial(int n) {
                 if (n == 0) {
                     return 1;
                 } else {
                     return n * factorial(n - 1);
                 }
             }
             int main() {
                 print(factorial(4));
                 return 0;
             }
         """,
         "description": "Recursion.",
         "expected_output": "24\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 print(read_int() + read_int());
                 return 0;
             }
         """,
         "description": "Read integers from input.",
         "expected_output": "15\n",
         "inputs": [5, 10]
     },
     {
         "code": """
             int main() {
                 bool a = read_bool();
                 bool b = read_bool();
                 if (a && b) {
                     print("Both true");
                 } else {
                     print("At least one false");
                 }
                 return 0;
             }
         """,
         "description": "Read booleans and logical AND.",
         "expected_output": "At least one false\n",
         "inputs": [True, False]
     },
     {
         "code": """
             int main() {
                 string name = read_str();
                 print("Hello, " + name + "!");
                 return 0;
             }
         """,
         "description": "Read string and string concatenation.",
         "expected_output": "Hello, World!\n",
         "inputs": ["World"]
     },
     {
         "code": """
             int calculate(int x, int y) {
                 return (x * 2) + (y / 2);
             }
             int main() {
                 print(calculate(5 + 1, 10 - 2));
                 return 0;
             }
         """,
         "description": "Complex expressions inside function call parameters.",
         "expected_output": "16\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int a = 10;
                 int b = 3;
                 print(a % b);
                 print(-a);
                 bool c = true;
                 print(!c);
                 return 0;
             }
         """,
         "description": "Modulo and unary operators.",
         "expected_output": "1\n-10\nfalse\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int i = 0;
                 for (; i < 2; ) {
                     print(i);
                     i = i + 1;
                 }
                 return 0;
             }
         """,
         "description": "For loop with empty initialization and increment parts.",
         "expected_output": "0\n1\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 int y = 0;
                 if (x > 5 && y == 0) {
                     print("Condition true");
                 }
                 if (x < 5 || y == 0) {
                     print("Another condition true");
                 }
                 return 0;
             }
         """,
         "description": "Logical AND and OR operators.",
         "expected_output": "Condition true\nAnother condition true\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int i = 0;
                 {
                     int i = 2;
                     print(i);
                 }
                 print(i);
                 return 0;
             }
         """,
         "description": "Scope handling with block statements.",
         "expected_output": "2\n0\n",
         "inputs": []
     },
     {
         "code": """
             int sum_up_to(int n) {
                 int sum = 0;
                 for (int i = 1; i <= n; i = i + 1) {
                     sum = sum + i;
                 }
                 return sum;
             }
             int main() {
                 print(sum_up_to(5));
                 return 0;
             }
         """,
         "description": "Function with for loop.",
         "expected_output": "15\n",
         "inputs": []
     },
     {
         "code": """
             string greet(string name) {
                 return "Hello, " + name;
             }
             int main() {
                 print(greet("Alice"));
                 return 0;
             }
         """,
         "description": "Function returning string.",
         "expected_output": "Hello, Alice\n",
         "inputs": []
     },
     {
         "code": """
             bool is_even(int n) {
                 return n % 2 == 0;
             }
             int main() {
                 print(is_even(4));
                 print(is_even(7));
                 return 0;
             }
         """,
         "description": "Function returning boolean.",
         "expected_output": "true\nfalse\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 int y = 0;
                 print(x / y);
                 return 0;
             }
         """,
         "description": "Runtime error: Division by zero.",
         "expected_output": "Error: Runtime Error: Division by zero at line 6, column 22\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10
                 print(x);
                 return 0;
             }
         """,
         "description": "Syntax error: Missing semicolon.",
         "expected_output": "Error: Syntax Error: Expected one of SEMICOLON, got PRINT at line 5, column 17\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 x = "hello";
                 print(x);
                 return 0;
             }
         """,
         "description": "Static Type error: Type mismatch on assignment.",
         "expected_output": "Error: Type Error: Type mismatch in assignment for 'x': expected int, got string. at line 5, column 17\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x;
                 print(x);
                 return 0;
             }
         """,
         "description": "Runtime error: Undefined variable access.",
         "expected_output": "Error: Runtime Error: Undefined variable 'x' at line 5, column 23\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 int x = 20;
                 print(x);
                 return 0;
             }
         """,
         "description": "Static Type error: Variable redeclaration in same scope.",
         "expected_output": "Error: Type Error: Variable 'x' already defined in this scope. at line 5, column 17\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 print(10 + "hello");
                 return 0;
             }
         """,
         "description": "Static Type error: Type mismatch for binary operation.",
         "expected_output": "Error: Type Error: Unsupported operand types for +: int and string. at line 4, column 22\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 if (x) {
                     print("true");
                 }
                 return 0;
             }
         """,
         "description": "Static Type error: Non-boolean condition in if.",
         "expected_output": "Error: Type Error: If condition must be of type 'bool'. at line 5, column 20\n",
         "inputs": []
     },
     {
         "code": """
             int foo() {
                 return;
             }
             int main() {
                 foo();
                 return 0;
             }
         """,
         "description": "Static Type error: Function declared int but returns nothing.",
         "expected_output": "Error: Type Error: Function declared to return 'int' but returned nothing. at line 3, column 17\n",
         "inputs": []
     },
     {
         "code": """
             void bar() {
                 return 1;
             }
             int main() {
                 bar();
                 return 0;
             }
         """,
         "description": "Static Type error: Function declared void but returns value.",
         "expected_output": "Error: Type Error: Function declared as 'void' but returns a value. at line 3, column 17\n",
         "inputs": []
     },
     {
         "code": """
             int sum(int a, int b) {
                 return a + b;
             }
             int main() {
                 print(sum(1, "two"));
                 return 0;
             }
         """,
         "description": "Static Type error: Type mismatch in function call argument.",
         "expected_output": "Error: Type Error: Type mismatch for argument 2 in function 'sum': expected int, got string. at line 5, column 27\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 x = x + 1;
                 print(x);
                 return 0;
             }
         """,
         "description": "Self-assignment with arithmetic.",
         "expected_output": "11\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 print(read_int());
                 return 0;
             }
         """,
         "description": "Runtime error: No input for read_int.",
         "expected_output": "Error: Runtime Error: No input provided for read_int(). at line 4, column 23\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 print(read_int());
                 return 0;
             }
         """,
         "description": "Runtime error: Wrong input type for read_int.",
         "expected_output": "Error: Runtime Error: Expected int input for read_int(), got str. at line 4, column 23\n",
         "inputs": ["hello"]
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 /* Multi-line comment
                 * Another line
                 */
                 print(x);
                 return 0;
             }
         """,
         "description": "Multi-line comments.",
         "expected_output": "10\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10; // Single-line comment
                 print(x);
                 return 0;
             }
         """,
         "description": "Single-line comments.",
         "expected_output": "10\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 string s = "Hello\\nWorld";
                 print(s);
                 return 0;
             }
         """,
         "description": "String with newline escape sequence.",
         "expected_output": "Hello\nWorld\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 string s = "Path: C:\\\\Users\\\\";
                 print(s);
                 return 0;
             }
         """,
         "description": "String with backslash escape sequence.",
         "expected_output": "Path: C:\\Users\\\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 string s = "Quote: \\"Hello\\"";
                 print(s);
                 return 0;
             }
         """,
         "description": "String with double quote escape sequence.",
         "expected_output": "Quote: \"Hello\"\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 int y = 20;
                 int z = 30;
                 if (x < y && y < z) {
                     print("Chain comparison true");
                 }
                 if (x > y || y < z) {
                     print("Mixed comparison true");
                 }
                 return 0;
             }
         """,
         "description": "Complex logical expressions.",
         "expected_output": "Chain comparison true\nMixed comparison true\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 for (x = 0; x < 2; x = x + 1) {
                     print(x);
                 }
                 return 0;
             }
         """,
         "description": "For loop with assignment in initialization.",
         "expected_output": "0\n1\n",
         "inputs": []
     },
     {
         "code": """
             int get_val() { return 5; }
             int main() {
                 int i = 0;
                 for (i = 0; i < 2; i = get_val()) {
                     print(i);
                 }
                 return 0;
             }
         """,
         "description": "For loop with function call in increment.",
         "expected_output": "0\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 if (true) {
                     print("True block");
                 }
                 if (false) {
                     print("False block");
                 } else {
                     print("Else block");
                 }
                 return 0;
             }
         """,
         "description": "If statements with boolean literals.",
         "expected_output": "True block\nElse block\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 int y = 20;
                 // z is not declared
                 if (x < y) {
                     if (y < z) {
                         print("Nested if true");
                     }
                 }
                 return 0;
             }
         """,
         "description": "Static Type error: Undeclared variable in nested if.",
         "expected_output": "Error: Type Error: Undeclared identifier 'z'. at line 7, column 29\n",
         "inputs": []
     },
     {
         "code": """
             int get_five() {
                 return 5;
             }
             int main() {
                 print(get_five());
                 return 0;
             }
         """,
         "description": "Function call returning a value.",
         "expected_output": "5\n",
         "inputs": []
     },
     {
         "code": """
             void do_nothing() {
             }
             int main() {
                 do_nothing();
                 print("Done");
                 return 0;
             }
         """,
         "description": "Void function call.",
         "expected_output": "Done\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 print( (x + 5) * 2 );
                 return 0;
             }
         """,
         "description": "Parenthesized expressions.",
         "expected_output": "30\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 print(true);
                 print(false);
                 return 0;
             }
         """,
         "description": "Printing boolean literals.",
         "expected_output": "true\nfalse\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 int y = 20;
                 print(x == y);
                 print(x != y);
                 return 0;
             }
         """,
         "description": "Equality and inequality operators.",
         "expected_output": "false\ntrue\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 int y = 10;
                 print(x == y);
                 print(x != y);
                 return 0;
             }
         """,
         "description": "Equality and inequality operators with equal values.",
         "expected_output": "true\nfalse\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 int y = 5;
                 print(x > y);
                 print(x < y);
                 print(x >= y);
                 print(x <= y);
                 print(x >= 10);
                 print(x <= 10);
                 return 0;
             }
         """,
         "description": "Relational operators.",
         "expected_output": "true\nfalse\ntrue\nfalse\ntrue\ntrue\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 int y = 2;
                 int z = 3;
                 print(x / y * z);
                 print(x * y / z);
                 print(x + y * z);
                 return 0;
             }
         """,
         "description": "Operator precedence.",
         "expected_output": "15\n6\n16\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = true;
                 return 0;
             }
         """,
         "description": "Static Type error: Type mismatch in variable declaration.",
         "expected_output": "Error: Type Error: Type mismatch in variable declaration for 'x': expected int, got bool. at line 4, column 25\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 if (10) {
                     print("true");
                 }
                 return 0;
             }
         """,
         "description": "Static Type error: Non-boolean condition in if statement.",
         "expected_output": "Error: Type Error: If condition must be of type 'bool'. at line 4, column 20\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 string s = "hello";
                 print(x == s);
                 return 0;
             }
         """,
         "description": "Static Type error: Incompatible types for equality comparison.",
         "expected_output": "Error: Type Error: Incompatible types for equality comparison '==': int and string. at line 5, column 27\n",
         "inputs": []
     },
     {
         "code": """
             int main() {
                 int x = 10;
                 bool b = true;
                 print(x < b);
                 return 0;
             }
         """,
         "description": "Static Type error: Incompatible types for relational comparison.",
         "expected_output": "Error: Type Error: Comparison operator '<' only supported for integers, got int and bool. at line 5, column 25\n",
         "inputs": []
     },
     {
         "code": """
            int global_var = 10;
            int main() {
                print(global_var);
                return 0;
            }
        """,
        "description": "Global variable declaration and access.",
        "expected_output": "10\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                int x = 10;
                int y = 20;
                print(x + y);
            }
        """,
        "description": "Runtime error: Missing return statement in int main().",
        "expected_output": "Error: Runtime Error: Function 'main' declared to return 'int' but returned nothing. at line 3, column 17\n",
        "inputs": []
    },
    {
        "code": """
            void foo() {
                print("Hello");
            }
            int main() {
                foo();
                return 0;
            }
        """,
        "description": "Void function call as statement.",
        "expected_output": "Hello\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                int x = 10;
                {
                    int y = 20;
                    print(x + y);
                }
                return 0;
            }
        """,
        "description": "Nested block scope with outer variable access.",
        "expected_output": "30\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                int x = 10;
                int y = 20;
                int z = 30;
                if (x < y) {
                    int z_inner = x + y;
                    print(z_inner);
                } else {
                    int w_inner = x - y;
                    print(w_inner);
                }
                return 0;
            }
        """,
        "description": "Variable declaration within if-else blocks.",
        "expected_output": "30\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                int x = 10;
                while (x > 0) {
                    int y_inner = x;
                    print(y_inner);
                    x = x - 5;
                }
                return 0;
            }
        """,
        "description": "Variable declaration within while loop.",
        "expected_output": "10\n5\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                int x = 10;
                {
                    string x = "hello";
                    print(x);
                }
                print(x);
                return 0;
            }
        """,
        "description": "Shadowing variable in inner block.",
        "expected_output": "hello\n10\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                int x = 10;
                x = !x;
                return 0;
            }
        """,
        "description": "Static Type error: Type mismatch with unary operator.",
        "expected_output": "Error: Type Error: Type mismatch in assignment for 'x': expected int, got bool. at line 5, column 21\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                int x;
                x = 10;
                print(x);
                return 0;
            }
        """,
        "description": "Variable declaration without initialization, then assignment.",
        "expected_output": "10\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                int x = 10;
                int y = 20;
                int z = (x + y) * 2;
                print(z);
                return 0;
            }
        """,
        "description": "Complex expression with multiple operators and parentheses.",
        "expected_output": "60\n",
        "inputs": []
    },
    {
        "code": """
            int a = 1;
            int b = 2;
            int c = 3;
            int main() {
                print(a + b * c);
                print((a + b) * c);
                return 0;
            }
        """,
        "description": "Operator precedence and associativity.",
        "expected_output": "7\n9\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                int x = 10;
                int y = 0;
                while (x > 0 && y < 5) {
                    print(x);
                    x = x - 1;
                    y = y + 1;
                }
                return 0;
            }
        """,
        "description": "While loop with complex logical condition.",
        "expected_output": "10\n9\n8\n7\n6\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                int x = 10;
                for (int i = 0; i < x; i = i + 1) {
                    if (i % 2 == 0) {
                        print(i);
                    }
                }
                return 0;
            }
        """,
        "description": "For loop with nested if and modulo operator.",
        "expected_output": "0\n2\n4\n6\n8\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                string s1 = "hello";
                string s2 = "world";
                print(s1 + s2);
                print(s1 == s2);
                print(s1 != s2);
                return 0;
            }
        """,
        "description": "String concatenation and comparison.",
        "expected_output": "helloworld\nfalse\ntrue\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                bool b1 = true;
                bool b2 = false;
                print(b1 && b2);
                print(b1 || b2);
                print(!b1);
                return 0;
            }
        """,
        "description": "Boolean logical operations.",
        "expected_output": "false\ntrue\nfalse\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                int x = 10;
                void y;
                return 0;
            }
        """,
        "description": "Static Type error: Declaring a void variable.",
        "expected_output": "Error: Type Error: Cannot declare variable of type 'void'. at line 5, column 17\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                int x = 10;
                int y = 20;
                int z = 30;
                if (x < y) {
                    print(z);
                }
                return 0;
            }
        """,
        "description": "Simple if statement.",
        "expected_output": "30\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                int x = 10;
                int y = 20;
                int z = 30;
                if (x > y) {
                    print(z);
                } else {
                    print(y);
                }
                return 0;
            }
        """,
        "description": "Simple if-else statement.",
        "expected_output": "20\n",
        "inputs": []
    },
    {
        "code": """
            int main() {
                int x = 10;
                int y = 20;
                int z = 30;
                if (x > y) {
                    print(z);
                } else if (x == 10) {
                    print(x);
                } else {
                    print(y);
                }
                return 0;
            }
        """,
        "description": "If-else if-else statement.",
        "expected_output": "10\n",
        "inputs": []
    },
]
 
 # --- Test Runner ---
 def run_tests():
     total_tests = len(TEST_PROGRAMS)
     passed_tests = 0
     results = []
 
     print(f"Running {total_tests} tests...")
 
     for i, test_case in enumerate(TEST_PROGRAMS):
         code = test_case["code"]
         description = test_case["description"]
         expected_output = test_case["expected_output"]
         inputs = test_case.get("inputs", [])
 
         actual_output = ""
         try:
             actual_output = interpreter_main(code, inputs)
             if actual_output == expected_output:
                 status = "PASS"
                 passed_tests += 1
             else:
                 status = "FAIL"
         except Exception as e:
             status = "ERROR"
             actual_output = f"Interpreter crashed: {e}\n"
 
         results.append({"description": description, "status": status, "actual_output": actual_output, "expected_output": expected_output})
 
     print("\n--- Test Summary ---")
     for res in results:
         print(f"[{res['status']}] {res['description']}")
         if res['status'] != 'PASS':
             print(f"  Expected:\n{res['expected_output'].strip()}")
             print(f"  Actual:\n{res['actual_output'].strip()}")
 
     print(f"\nTotal Tests: {total_tests}, Passed: {passed_tests}, Failed: {total_tests - passed_tests}")
     return passed_tests == total_tests
 
 # --- Command Line Interface ---
 def main():
     parser = argparse.ArgumentParser(description="A C-like language interpreter.")
     parser.add_argument("file", nargs='?', help="Path to the program file to execute.")
     parser.add_argument("--test", action="store_true", help="Run embedded test suite.")
     parser.add_argument("--syntax", action="store_true", help="Print language syntax documentation.")
 
     args = parser.parse_args()
 
     if args.syntax:
         print(LANGUAGE_SPECIFICATION)
         sys.exit(0)
 
     if args.test:
         success = run_tests()
         sys.exit(0 if success else 1)
 
     if args.file:
         try:
             with open(args.file, 'r') as f:
                 program_code = f.read()
             output = interpreter_main(program_code)
             sys.stdout.write(output)
         except FileNotFoundError:
             print(f"Error: File not found: {args.file}")
             sys.exit(1)
         except Exception as e:
             print(f"Error executing program: {e}")
             sys.exit(1)
     else:
         parser.print_help()
         sys.exit(1)
 
 if __name__ == "__main__":
     main()