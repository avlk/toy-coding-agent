--- a/main.py
+++ b/main.py
@@ -93,7 +93,6 @@
                     token_type = 'TYPE'
                 elif token_value == 'true' or token_value == 'false':
                     token_type = 'BOOLEAN'
-                else: # Convert keywords like 'if', 'else' to their uppercase type
-                    token_type = token_value.upper() # e.g., IF, ELSE, WHILE, RETURN, PRINT, etc.
                  token_type = token_value.upper() # e.g., IF, ELSE, WHILE
 
             self.tokens.append(Token(token_type, token_value, token_line, token_column))
@@ -351,12 +350,56 @@
                 token.line, token.column
             )
 
-# --- Type Checker (Skeleton) ---
+# --- Type Checker ---
+class TypeSymbolTable:
+    def __init__(self, parent=None):
+        self.symbols = {} # Stores {'name': 'type_name'}
+        self.parent = parent
+
+    def define(self, name, type_name, node_for_error=None):
+        if name in self.symbols:
+            raise TypeError(f"Variable '{name}' already defined in this scope.", node_for_error.line, node_for_error.column)
+        self.symbols[name] = type_name
+
+    def resolve(self, name):
+        if name in self.symbols:
+            return self.symbols[name]
+        if self.parent:
+            return self.parent.resolve(name)
+        return None # Not found
+
 class TypeChecker:
     def __init__(self):
-        self.symbol_table = {} # Global scope for now
+        self.global_type_scope = TypeSymbolTable()
+        self.current_type_scope = self.global_type_scope
+        self.function_signatures = {} # Stores {'func_name': {'return_type': 'type', 'param_types': ['type', ...]}}
         self.current_function_return_type = None
 
+        # Register built-in functions
+        self.function_signatures['print'] = {'return_type': 'void', 'param_types': ['any']} # 'any' for print
+        self.function_signatures['read_int'] = {'return_type': 'int', 'param_types': []}
+        self.function_signatures['read_bool'] = {'return_type': 'bool', 'param_types': []}
+        self.function_signatures['read_str'] = {'return_type': 'string', 'param_types': []}
+
+    def _enter_scope(self):
+        self.current_type_scope = TypeSymbolTable(self.current_type_scope)
+
+    def _exit_scope(self):
+        self.current_type_scope = self.current_type_scope.parent
+
     def check(self, ast):
-        # This is a placeholder for a full static type checker.
-        # The interpreter performs dynamic type checks during execution.
-        pass
+        # First pass: register function declarations and global variables
+        for stmt in ast.statements:
+            if isinstance(stmt, FunctionDecl):
+                if stmt.name in self.function_signatures:
+                    raise TypeError(f"Function '{stmt.name}' already defined.", stmt.line, stmt.column)
+                param_types = [p_type_token.value for p_type_token, _ in stmt.parameters]
+                self.function_signatures[stmt.name] = {
+                    'return_type': stmt.return_type,
+                    'param_types': param_types
+                }
+            elif isinstance(stmt, VariableDecl):
+                self._check_variable_declaration(stmt) # Check global variable declarations
+
+        # Second pass: type check all function bodies and ensure no other top-level statements
+        for stmt in ast.statements:
+            if isinstance(stmt, FunctionDecl):
+                self._check_function_declaration_body(stmt)
+            elif not isinstance(stmt, VariableDecl):
+                raise TypeError(f"Top-level statements other than function or variable declarations are not allowed.", stmt.line, stmt.column)
+
+    def _check_statement(self, node):
+        if isinstance(node, VariableDecl):
+            self._check_variable_declaration(node)
+        elif isinstance(node, Assignment):
+            self._check_assignment(node)
+        elif isinstance(node, PrintStatement):
+            self._check_expression(node.expression) # Any type is fine for print
+        elif isinstance(node, IfStatement):
+            self._check_if_statement(node)
+        elif isinstance(node, WhileLoop):
+            self._check_while_loop(node)
+        elif isinstance(node, ForLoop):
+            self._check_for_loop(node)
+        elif isinstance(node, FunctionCall):
+            self._check_function_call(node) # Function calls can be statements
+        elif isinstance(node, ReturnStatement):
+            self._check_return_statement(node)
+        elif isinstance(node, BlockStatement):
+            self._enter_scope()
+            for stmt in node.statements:
+                self._check_statement(stmt)
+            self._exit_scope()
+
+    def _check_variable_declaration(self, node):
+        declared_type = node.var_type
+        if declared_type not in Lexer.TYPES:
+            raise TypeError(f"Unknown type '{declared_type}'", node.line, node.column)
+
+        if declared_type == 'void':
+            raise TypeError(f"Cannot declare variable of type 'void'.", node.line, node.column)
+
+        if node.expression:
+            expr_type = self._check_expression(node.expression)
+            if expr_type != declared_type:
+                raise TypeError(f"Type mismatch in variable declaration for '{node.name}': expected {declared_type}, got {expr_type}.", node.line, node.column)
+        self.current_type_scope.define(node.name, declared_type, node)
+
+    def _check_assignment(self, node):
+        var_type = self.current_type_scope.resolve(node.name)
+        if var_type is None:
+            raise TypeError(f"Undeclared variable '{node.name}'.", node.line, node.column)
+        
+        expr_type = self._check_expression(node.expression)
+        if var_type != expr_type:
+            raise TypeError(f"Type mismatch in assignment for '{node.name}': expected {var_type}, got {expr_type}.", node.line, node.column)
+
+    def _check_if_statement(self, node):
+        condition_type = self._check_expression(node.condition)
+        if condition_type != 'bool':
+            raise TypeError("If condition must be of type 'bool'.", node.condition.line, node.condition.column)
+        self._enter_scope()
+        for stmt in node.true_block:
+            self._check_statement(stmt)
+        self._exit_scope()
+        if node.else_block:
+            self._enter_scope()
+            for stmt in node.else_block:
+                self._check_statement(stmt)
+            self._exit_scope()
+
+    def _check_while_loop(self, node):
+        condition_type = self._check_expression(node.condition)
+        if condition_type != 'bool':
+            raise TypeError("While loop condition must be of type 'bool'.", node.condition.line, node.condition.column)
+        self._enter_scope()
+        for stmt in node.body:
+            self._check_statement(stmt)
+        self._exit_scope()
+
+    def _check_for_loop(self, node):
+        self._enter_scope()
+        if node.init:
+            self._check_statement(node.init) # init can be VarDecl or Assignment
+        
+        condition_type = self._check_expression(node.condition)
+        if condition_type != 'bool':
+            raise TypeError("For loop condition must be of type 'bool'.", node.condition.line, node.condition.column)
+        
+        for stmt in node.body:
+            self._check_statement(stmt)
+        
+        if node.increment:
+            # Increment can be an assignment or a function call
+            if isinstance(node.increment, Assignment):
+                self._check_assignment(node.increment)
+            elif isinstance(node.increment, FunctionCall):
+                self._check_function_call(node.increment)
+            else:
+                raise TypeError("Invalid increment statement in for loop.", node.increment.line, node.increment.column)
+        self._exit_scope()
+
+    def _check_function_declaration_body(self, node):
+        # This is called in the second pass to check the body
+        self.current_function_return_type = node.return_type
+        self._enter_scope()
+        # Define parameters in the new scope
+        for param_type_token, param_id_token in node.parameters:
+            self.current_type_scope.define(param_id_token.value, param_type_token.value, param_id_token)
+        
+        for stmt in node.body:
+            self._check_statement(stmt)
+        self._exit_scope()
+        self.current_function_return_type = None
+
+    def _check_return_statement(self, node):
+        if self.current_function_return_type is None:
+            raise TypeError("Return statement outside of a function.", node.line, node.column)
+        
+        if node.expression:
+            expr_type = self._check_expression(node.expression)
+            if self.current_function_return_type == 'void':
+                raise TypeError(f"Function declared as 'void' but returns a value.", node.line, node.column)
+            if expr_type != self.current_function_return_type:
+                raise TypeError(f"Return type mismatch: expected {self.current_function_return_type}, got {expr_type}.", node.line, node.column)
+        else: # No expression
+            if self.current_function_return_type != 'void':
+                raise TypeError(f"Function declared to return '{self.current_function_return_type}' but returns nothing.", node.line, node.column)
+
+    def _check_expression(self, node):
+        if isinstance(node, Literal):
+            return node.type_name
+        elif isinstance(node, Identifier):
+            var_type = self.current_type_scope.resolve(node.name)
+            if var_type is None:
+                raise TypeError(f"Undeclared identifier '{node.name}'.", node.line, node.column)
+            return var_type
+        elif isinstance(node, BinaryOp):
+            left_type = self._check_expression(node.left)
+            right_type = self._check_expression(node.right)
+            op = node.op
+
+            if op in ('+', '-', '*', '/', '%'):
+                if left_type == 'int' and right_type == 'int':
+                    return 'int'
+                if op == '+' and left_type == 'string' and right_type == 'string':
+                    return 'string'
+                raise TypeError(f"Unsupported operand types for {op}: {left_type} and {right_type}.", node.line, node.column)
+            elif op in ('==', '!='):
+                if left_type == right_type: # Allow comparison of same types
+                    return 'bool'
+                raise TypeError(f"Incompatible types for equality comparison '{op}': {left_type} and {right_type}.", node.line, node.column)
+            elif op in ('<', '>', '<=', '>='):
+                if left_type == 'int' and right_type == 'int':
+                    return 'bool'
+                raise TypeError(f"Comparison operator '{op}' only supported for integers, got {left_type} and {right_type}.", node.line, node.column)
+            elif op in ('&&', '||'):
+                if left_type == 'bool' and right_type == 'bool':
+                    return 'bool'
+                raise TypeError(f"Operands for '{op}' must be booleans, got {left_type} and {right_type}.", node.line, node.column)
+            else:
+                raise TypeError(f"Unknown binary operator: {op}", node.line, node.column)
+        elif isinstance(node, UnaryOp):
+            right_type = self._check_expression(node.right)
+            op = node.op
+            if op == '-':
+                if right_type == 'int':
+                    return 'int'
+                raise TypeError(f"Unsupported operand type for unary -: {right_type}.", node.line, node.column)
+            elif op == '!':
+                if right_type == 'bool':
+                    return 'bool'
+                raise TypeError(f"Unsupported operand type for unary !: {right_type}.", node.line, node.column)
+            else:
+                raise TypeError(f"Unknown unary operator: {op}", node.line, node.column)
+        elif isinstance(node, FunctionCall):
+            return self._check_function_call(node)
+        else:
+            raise TypeError(f"Unknown expression type during type checking: {type(node).__name__}", node.line, node.column)
+
+    def _check_function_call(self, node):
+        func_name = node.name
+        if func_name not in self.function_signatures:
+            raise TypeError(f"Undefined function '{func_name}'.", node.line, node.column)
+        
+        func_sig = self.function_signatures[func_name]
+        
+        if func_name == 'print': # Special handling for 'any' type
+            if len(node.arguments) != 1:
+                raise TypeError("print() expects exactly one argument.", node.line, node.column)
+            self._check_expression(node.arguments[0]) # Just check it's a valid expression
+            return 'void'
+
+        if len(node.arguments) != len(func_sig['param_types']):
+            raise TypeError(f"Function '{func_name}' expects {len(func_sig['param_types'])} arguments, but got {len(node.arguments)}.", node.line, node.column)
+        
+        for i, (arg_expr, expected_param_type) in enumerate(zip(node.arguments, func_sig['param_types'])):
+            actual_arg_type = self._check_expression(arg_expr)
+            if actual_arg_type != expected_param_type:
+                raise TypeError(f"Type mismatch for argument {i+1} in function '{func_name}': expected {expected_param_type}, got {actual_arg_type}.", arg_expr.line, arg_expr.column)
+        
+        return func_sig['return_type']
 
 # --- Interpreter ---
 class SymbolTable:
@@ -367,7 +410,7 @@
 
     def define(self, name, type_name, value=None):
         if name in self.symbols:
-            raise RuntimeError(f"Variable '{name}' already defined in this scope.")
+            raise RuntimeError(f"Variable '{name}' already defined in this scope.", node_for_error=None) # No node for error here, TypeChecker should catch this
         self.symbols[name] = {'type': type_name, 'value': value}
 
     def assign(self, name, value, node_for_error=None):
@@ -375,7 +418,7 @@
             # Type check assignment (basic)
             expected_type = scope[name]['type']
             actual_type = self._get_runtime_type(value)
-            if expected_type != 'void' and expected_type != actual_type: # void can't be assigned
+            if expected_type != 'void' and expected_type != actual_type: # void can't be assigned, and types must match
                 raise RuntimeError(f"Type mismatch for variable '{name}': expected {expected_type}, got {actual_type}",
                                    node_for_error.line, node_for_error.column)
             scope[name]['value'] = value
@@ -415,25 +458,37 @@
         self.output_buffer = []
         self.input_queue = deque(inputs if inputs is not None else [])
         self.functions = {} # Stores FunctionDecl nodes
-
-        # Built-in functions are handled specially, not defined in symbol table
-        # as they don't have a 'value' in the same way variables do.
-        # Their existence is checked in _call_function.
 
     def _enter_scope(self):
         self.current_scope = SymbolTable(self.current_scope)
 
     def _exit_scope(self):
         self.current_scope = self.current_scope.parent
-
+    
     def interpret(self):
         # First pass: register function declarations
         for stmt in self.program_ast.statements:
             if isinstance(stmt, FunctionDecl):
                 if stmt.name in self.functions:
                     raise RuntimeError(f"Function '{stmt.name}' already defined.", stmt.line, stmt.column)
                 self.functions[stmt.name] = stmt
-
-        # Execute global statements (excluding function declarations)
+            elif isinstance(stmt, VariableDecl):
+                # Execute global variable declarations
+                self._execute_statement(stmt)
+            else:
+                raise RuntimeError(f"Top-level statements other than function or variable declarations are not allowed.", stmt.line, stmt.column)
+
+        # Call main function
+        if 'main' not in self.functions:
+            raise RuntimeError("Program entry point 'main' function not found.")
+        
+        main_func_decl = self.functions['main']
+        # TypeChecker should have already validated main's signature, but a runtime check for robustness
+        if main_func_decl.return_type != 'int' or len(main_func_decl.parameters) != 0:
+            raise RuntimeError("Function 'main' must have signature 'int main()'.", main_func_decl.line, main_func_decl.column)
+
+        # Create a dummy FunctionCall node for main to reuse _call_function logic
+        main_call_node = FunctionCall(Token('IDENTIFIER', 'main', main_func_decl.line, main_func_decl.column), [])
+        self._call_function(main_call_node) # Execute main
+
+        return "".join(self.output_buffer)
+
+    def _execute_statement(self, node):
+        if isinstance(node, VariableDecl):
+            value = None
+            if node.expression:
+                value = self._evaluate_expression(node.expression)
+            self.current_scope.define(node.name, node.var_type, value)
+        elif isinstance(node, Assignment):
+            value = self._evaluate_expression(node.expression)
+            self.current_scope.assign(node.name, value, node)
+        elif isinstance(node, PrintStatement):
+            value = self._evaluate_expression(node.expression)
+            self.output_buffer.append(str(value).lower() if isinstance(value, bool) else str(value) + "\n") # 'true'/'false' for bools
+        elif isinstance(node, IfStatement):
+            condition_value = self._evaluate_expression(node.condition)
+            # TypeChecker ensures condition_value is bool
+            self._enter_scope()
+            if condition_value:
+                for stmt in node.true_block:
+                    self._execute_statement(stmt)
+            elif node.else_block:
+                for stmt in node.else_block:
+                    self._execute_statement(stmt)
+            self._exit_scope()
+        elif isinstance(node, WhileLoop):
+            self._enter_scope()
+            while True:
+                condition_value = self._evaluate_expression(node.condition)
+                # TypeChecker ensures condition_value is bool
+                if not condition_value:
+                    break
+                for stmt in node.body:
+                    self._execute_statement(stmt)
+            self._exit_scope()
+        elif isinstance(node, ForLoop):
+            self._enter_scope()
+            if node.init:
+                self._execute_statement(node.init)
+            while True:
+                condition_value = self._evaluate_expression(node.condition)
+                # TypeChecker ensures condition_value is bool
+                if not condition_value:
+                    break
+                for stmt in node.body:
+                    self._execute_statement(stmt)
+                if node.increment:
+                    # For increment, it's an expression statement, so we just evaluate it.
+                    # It could be an assignment or a function call.
+                    if isinstance(node.increment, Assignment):
+                        self._execute_statement(node.increment)
+                    elif isinstance(node.increment, FunctionCall):
+                        self._evaluate_expression(node.increment) # Execute for side effects
+                    else:
+                        # TypeChecker should catch this, but a runtime check for robustness
+                        raise RuntimeError("Invalid increment statement in for loop.", node.increment.line, node.increment.column)
+            self._exit_scope()
+        elif isinstance(node, FunctionCall):
+            # If a function call is a statement, we just evaluate it for side effects
+            self._evaluate_expression(node)
+        elif isinstance(node, ReturnStatement):
+            if node.expression:
+                value = self._evaluate_expression(node.expression)
+                raise ReturnValue(value)
+            else:
+                raise ReturnValue(None) # For void functions
+        elif isinstance(node, BlockStatement): # Correctly handle anonymous blocks
+            self._enter_scope()
+            for stmt in node.statements:
+                self._execute_statement(stmt)
+            self._exit_scope()
+        else:
+            raise RuntimeError(f"Unknown statement type: {type(node).__name__}", node.line, node.column)
+
+
+    def _evaluate_expression(self, node):
+        if isinstance(node, Literal):
+            return node.value
+        elif isinstance(node, Identifier):
+            return self.current_scope.get(node.name, node)
+        elif isinstance(node, BinaryOp):
+            left_val = self._evaluate_expression(node.left)
+            right_val = self._evaluate_expression(node.right)
+
+            op = node.op
+            # TypeChecker ensures operand types are compatible.
+            # Only specific runtime checks like division by zero are needed.
+            if op == '+':
+                return left_val + right_val
+            elif op == '-':
+                return left_val - right_val
+            elif op == '*':
+                return left_val * right_val
+            elif op == '/':
+                if right_val == 0:
+                    raise RuntimeError("Division by zero", node.line, node.column)
+                return left_val // right_val # Integer division
+            elif op == '%':
+                if right_val == 0:
+                    raise RuntimeError("Modulo by zero", node.line, node.column)
+                return left_val % right_val
+            elif op == '==': return left_val == right_val
+            elif op == '!=': return left_val != right_val
+            elif op == '<':  return left_val < right_val
+            elif op == '>':  return left_val > right_val
+            elif op == '<=': return left_val <= right_val
+            elif op == '>=': return left_val >= right_val
+            elif op == '&&':
+                return left_val and right_val
+            elif op == '||':
+                return left_val or right_val
+            else:
+                raise RuntimeError(f"Unknown binary operator: {op}", node.line, node.column)
+        elif isinstance(node, UnaryOp):
+            right_val = self._evaluate_expression(node.right)
+            op = node.op
+            # TypeChecker ensures operand types are compatible.
+            if op == '-':
+                return -right_val
+            elif op == '!':
+                return not right_val
+            else:
+                raise RuntimeError(f"Unknown unary operator: {op}", node.line, node.column)
+        elif isinstance(node, FunctionCall):
+            return self._call_function(node)
+        else:
+            raise RuntimeError(f"Unknown expression type: {type(node).__name__}", node.line, node.column)
+
+    def _call_function(self, node):
+        func_name = node.name
+        args = [self._evaluate_expression(arg_expr) for arg_expr in node.arguments]
+
+        # Handle built-in functions
+        if func_name == 'print':
+            # TypeChecker ensures argument count.
+            self.output_buffer.append(str(args[0]).lower() if isinstance(args[0], bool) else str(args[0]) + "\n")
+            return None # print returns void
+        elif func_name == 'read_int':
+            # TypeChecker ensures argument count.
+            if not self.input_queue:
+                raise RuntimeError("No input provided for read_int().", node.line, node.column)
+            val = self.input_queue.popleft()
+            if not isinstance(val, int):
+                raise RuntimeError(f"Expected int input for read_int(), got {type(val).__name__}.", node.line, node.column)
+            return val
+        elif func_name == 'read_bool':
+            # TypeChecker ensures argument count.
+            if not self.input_queue:
+                raise RuntimeError("No input provided for read_bool().", node.line, node.column)
+            val = self.input_queue.popleft()
+            if not isinstance(val, bool):
+                raise RuntimeError(f"Expected bool input for read_bool(), got {type(val).__name__}.", node.line, node.column)
+            return val
+        elif func_name == 'read_str':
+            # TypeChecker ensures argument count.
+            if not self.input_queue:
+                raise RuntimeError("No input provided for read_str().", node.line, node.column)
+            val = self.input_queue.popleft()
+            if not isinstance(val, str):
+                raise RuntimeError(f"Expected string input for read_str(), got {type(val).__name__}.", node.line, node.column)
+            return val
+
+        # Handle user-defined functions
+        if func_name not in self.functions:
+            # TypeChecker should catch this, but a runtime check for robustness
+            raise RuntimeError(f"Undefined function '{func_name}'", node.line, node.column)
+
+        func_decl = self.functions[func_name]
+        # TypeChecker ensures argument count and types.
+
+        self._enter_scope()
+        # Bind parameters to arguments
+        for (param_type_token, param_id_token), arg_value in zip(func_decl.parameters, args):
+            # SymbolTable.define performs runtime type check against declared type
+            self.current_scope.define(param_id_token.value, param_type_token.value, arg_value)
+
+        return_value = None
+        try:
+            for stmt in func_decl.body:
+                self._execute_statement(stmt)
+        except ReturnValue as e:
+            return_value = e.value
+        finally:
+            self._exit_scope()
+
+        # Check return type (runtime check for actual value returned)
+        expected_return_type = func_decl.return_type
+        actual_return_type = self.current_scope._get_runtime_type(return_value)
+
+        if expected_return_type == 'void' and return_value is not None:
+            raise RuntimeError(f"Function '{func_name}' declared as 'void' but returned a value.", node.line, node.column)
+        if expected_return_type != 'void' and return_value is None:
+             raise RuntimeError(f"Function '{func_name}' declared to return '{expected_return_type}' but returned nothing.", node.line, node.column)
+        if expected_return_type != 'void' and expected_return_type != actual_return_type:
+            raise RuntimeError(f"Function '{func_name}' expected to return '{expected_return_type}', but returned '{actual_return_type}'.", node.line, node.column)
+
+        return return_value
+
+class ReturnValue(Exception):
+    """Special exception to propagate return values from functions."""
+    def __init__(self, value):
+        self.value = value
+
+# --- Main Interpreter Entry Point ---
+def interpreter_main(program_code: str, inputs: list = None) -> str:
+    """
+    Main entry point for the C-like language interpreter.
+
+    Args:
+        program_code (str): The multi-line text of the program.
+        inputs (list, optional): A list of inputs for read_int/bool/str calls.
+                                 Defaults to None, meaning real stdin will be used.
+
+    Returns:
+        str: The accumulated output of the program.
+    """
+    try:
+        lexer = Lexer(program_code)
+        tokens = lexer.get_tokens()
+
+        parser = Parser(tokens)
+        ast = parser.parse()
+
+        # Type checking
+        type_checker = TypeChecker()
+        type_checker.check(ast)
+
+        interpreter = Interpreter(ast, inputs)
+        output = interpreter.interpret()
+        return output
+    except InterpreterError as e:
+        return f"Error: {e}\n"
+    except Exception as e:
+        # Catch any unexpected Python errors during interpretation
+        return f"Unexpected Interpreter Error: {e}\n"
+
+# --- Test Programs ---
+TEST_PROGRAMS = [
+    {
+        "code": """
+            int main() {
+                print(10);
+                return 0;
+            }
+        """,
+        "description": "Basic print of an integer literal.",
+        "expected_output": "10\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 5;
+                int y = 10;
+                print(x + y);
+                return 0;
+            }
+        """,
+        "description": "Variable declaration, assignment, and arithmetic.",
+        "expected_output": "15\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                if (x > 5) {
+                    print("x is greater than 5");
+                } else {
+                    print("x is not greater than 5");
+                }
+                return 0;
+            }
+        """,
+        "description": "If-else statement with string literal.",
+        "expected_output": "x is greater than 5\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 3;
+                if (x == 5) {
+                    print("x is 5");
+                } else if (x < 5) {
+                    print("x is less than 5");
+                } else {
+                    print("x is greater than 5");
+                }
+                return 0;
+            }
+        """,
+        "description": "If-else if-else chain.",
+        "expected_output": "x is less than 5\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int i = 0;
+                while (i < 3) {
+                    print(i);
+                    i = i + 1;
+                }
+                return 0;
+            }
+        """,
+        "description": "While loop.",
+        "expected_output": "0\n1\n2\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                for (int i = 0; i < 3; i = i + 1) {
+                    print(i);
+                }
+                return 0;
+            }
+        """,
+        "description": "For loop.",
+        "expected_output": "0\n1\n2\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int add(int a, int b) {
+                return a + b;
+            }
+            int main() {
+                int result = add(5, 7);
+                print(result);
+                return 0;
+            }
+        """,
+        "description": "Function declaration and call.",
+        "expected_output": "12\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int factorial(int n) {
+                if (n == 0) {
+                    return 1;
+                } else {
+                    return n * factorial(n - 1);
+                }
+            }
+            int main() {
+                print(factorial(4));
+                return 0;
+            }
+        """,
+        "description": "Recursion.",
+        "expected_output": "24\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                print(read_int() + read_int());
+                return 0;
+            }
+        """,
+        "description": "Read integers from input.",
+        "expected_output": "15\n",
+        "inputs": [5, 10]
+    },
+    {
+        "code": """
+            int main() {
+                bool a = read_bool();
+                bool b = read_bool();
+                if (a && b) {
+                    print("Both true");
+                } else {
+                    print("At least one false");
+                }
+                return 0;
+            }
+        """,
+        "description": "Read booleans and logical AND.",
+        "expected_output": "At least one false\n",
+        "inputs": [True, False]
+    },
+    {
+        "code": """
+            int main() {
+                string name = read_str();
+                print("Hello, " + name + "!");
+                return 0;
+            }
+        """,
+        "description": "Read string and string concatenation.",
+        "expected_output": "Hello, World!\n",
+        "inputs": ["World"]
+    },
+    {
+        "code": """
+            int calculate(int x, int y) {
+                return (x * 2) + (y / 2);
+            }
+            int main() {
+                print(calculate(5 + 1, 10 - 2));
+                return 0;
+            }
+        """,
+        "description": "Complex expressions inside function call parameters.",
+        "expected_output": "16\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int a = 10;
+                int b = 3;
+                print(a % b);
+                print(-a);
+                bool c = true;
+                print(!c);
+                return 0;
+            }
+        """,
+        "description": "Modulo and unary operators.",
+        "expected_output": "1\n-10\nfalse\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int i = 0;
+                for (; i < 2; ) {
+                    print(i);
+                    i = i + 1;
+                }
+                return 0;
+            }
+        """,
+        "description": "For loop with empty initialization and increment parts.",
+        "expected_output": "0\n1\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 0;
+                if (x > 5 && y == 0) {
+                    print("Condition true");
+                }
+                if (x < 5 || y == 0) {
+                    print("Another condition true");
+                }
+                return 0;
+            }
+        """,
+        "description": "Logical AND and OR operators.",
+        "expected_output": "Condition true\nAnother condition true\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int i = 0;
+                {
+                    int i = 2;
+                    print(i);
+                }
+                print(i);
+                return 0;
+            }
+        """,
+        "description": "Scope handling with block statements.",
+        "expected_output": "2\n0\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int sum_up_to(int n) {
+                int sum = 0;
+                for (int i = 1; i <= n; i = i + 1) {
+                    sum = sum + i;
+                }
+                return sum;
+            }
+            int main() {
+                print(sum_up_to(5));
+                return 0;
+            }
+        """,
+        "description": "Function with for loop.",
+        "expected_output": "15\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            string greet(string name) {
+                return "Hello, " + name;
+            }
+            int main() {
+                print(greet("Alice"));
+                return 0;
+            }
+        """,
+        "description": "Function returning string.",
+        "expected_output": "Hello, Alice\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            bool is_even(int n) {
+                return n % 2 == 0;
+            }
+            int main() {
+                print(is_even(4));
+                print(is_even(7));
+                return 0;
+            }
+        """,
+        "description": "Function returning boolean.",
+        "expected_output": "true\nfalse\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 0;
+                print(x / y);
+                return 0;
+            }
+        """,
+        "description": "Runtime error: Division by zero.",
+        "expected_output": "Error: Runtime Error: Division by zero at line 6, column 22\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10
+                print(x);
+                return 0;
+            }
+        """,
+        "description": "Syntax error: Missing semicolon.",
+        "expected_output": "Error: Syntax Error: Expected one of SEMICOLON, got PRINT at line 5, column 17\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                x = "hello";
+                print(x);
+                return 0;
+            }
+        """,
+        "description": "Runtime error: Type mismatch on assignment.",
+        "expected_output": "Error: Runtime Error: Type mismatch for variable 'x': expected int, got string at line 5, column 17\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x;
+                print(x);
+                return 0;
+            }
+        """,
+        "description": "Runtime error: Undefined variable access.",
+        "expected_output": "Error: Runtime Error: Undefined variable 'x' at line 5, column 23\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int x = 20;
+                print(x);
+                return 0;
+            }
+        """,
+        "description": "Static Type error: Variable redeclaration in same scope.",
+        "expected_output": "Error: Type Error: Variable 'x' already defined in this scope. at line 5, column 17\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                print(10 + "hello");
+                return 0;
+            }
+        """,
+        "description": "Static Type error: Type mismatch for binary operation.",
+        "expected_output": "Error: Type Error: Unsupported operand types for +: int and string. at line 4, column 22\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                if (x) {
+                    print("true");
+                }
+                return 0;
+            }
+        """,
+        "description": "Static Type error: Non-boolean condition in if.",
+        "expected_output": "Error: Type Error: If condition must be of type 'bool'. at line 5, column 20\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int foo() {
+                return;
+            }
+            int main() {
+                foo();
+                return 0;
+            }
+        """,
+        "description": "Static Type error: Function declared int but returns nothing.",
+        "expected_output": "Error: Type Error: Function declared to return 'int' but returns nothing. at line 3, column 17\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            void bar() {
+                return 1;
+            }
+            int main() {
+                bar();
+                return 0;
+            }
+        """,
+        "description": "Static Type error: Function declared void but returns value.",
+        "expected_output": "Error: Type Error: Function declared as 'void' but returns a value. at line 3, column 17\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int sum(int a, int b) {
+                return a + b;
+            }
+            int main() {
+                print(sum(1, "two"));
+                return 0;
+            }
+        """,
+        "description": "Static Type error: Type mismatch in function call argument.",
+        "expected_output": "Error: Type Error: Type mismatch for argument 2 in function 'sum': expected int, got string. at line 5, column 27\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                x = x + 1;
+                print(x);
+                return 0;
+            }
+        """,
+        "description": "Self-assignment with arithmetic.",
+        "expected_output": "11\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                print(read_int());
+                return 0;
+            }
+        """,
+        "description": "Runtime error: No input for read_int.",
+        "expected_output": "Error: Runtime Error: No input provided for read_int(). at line 4, column 23\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                print(read_int());
+                return 0;
+            }
+        """,
+        "description": "Runtime error: Wrong input type for read_int.",
+        "expected_output": "Error: Runtime Error: Expected int input for read_int(), got str. at line 4, column 23\n",
+        "inputs": ["hello"]
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                print(x);
+                return 0;
+            }
+        """,
+        "description": "Multi-line comments.",
+        "expected_output": "10\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                print(x);
+                return 0;
+            }
+        """,
+        "description": "Single-line comments.",
+        "expected_output": "10\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                string s = "Hello\\nWorld";
+                print(s);
+                return 0;
+            }
+        """,
+        "description": "String with newline escape sequence.",
+        "expected_output": "Hello\nWorld\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                string s = "Path: C:\\\\Users\\\\";
+                print(s);
+                return 0;
+            }
+        """,
+        "description": "String with backslash escape sequence.",
+        "expected_output": "Path: C:\\Users\\\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                string s = "Quote: \\"Hello\\"";
+                print(s);
+                return 0;
+            }
+        """,
+        "description": "String with double quote escape sequence.",
+        "expected_output": "Quote: \"Hello\"\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 20;
+                int z = 30;
+                if (x < y && y < z) {
+                    print("Chain comparison true");
+                }
+                if (x > y || y < z) {
+                    print("Mixed comparison true");
+                }
+                return 0;
+            }
+        """,
+        "description": "Complex logical expressions.",
+        "expected_output": "Chain comparison true\nMixed comparison true\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                for (x = 0; x < 2; x = x + 1) {
+                    print(x);
+                }
+                return 0;
+            }
+        """,
+        "description": "For loop with assignment in initialization.",
+        "expected_output": "0\n1\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int get_val() { return 5; }
+            int main() {
+                int i = 0;
+                for (i = 0; i < 2; i = get_val()) {
+                    print(i);
+                }
+                return 0;
+            }
+        """,
+        "description": "For loop with function call in increment.",
+        "expected_output": "0\n5\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                if (true) {
+                    print("True block");
+                }
+                if (false) {
+                    print("False block");
+                } else {
+                    print("Else block");
+                }
+                return 0;
+            }
+        """,
+        "description": "If statements with boolean literals.",
+        "expected_output": "True block\nElse block\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 20;
+                if (x < y) {
+                    if (y < z) {
+                        print("Nested if true");
+                    }
+                }
+                return 0;
+            }
+        """,
+        "description": "Nested if statements.",
+        "expected_output": "Nested if true\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int get_five() {
+                return 5;
+            }
+            int main() {
+                print(get_five());
+                return 0;
+            }
+        """,
+        "description": "Function call returning a value.",
+        "expected_output": "5\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            void do_nothing() {
+            }
+            int main() {
+                do_nothing();
+                print("Done");
+                return 0;
+            }
+        """,
+        "description": "Void function call.",
+        "expected_output": "Done\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                print( (x + 5) * 2 );
+                return 0;
+            }
+        """,
+        "description": "Parenthesized expressions.",
+        "expected_output": "30\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                print(true);
+                print(false);
+                return 0;
+            }
+        """,
+        "description": "Printing boolean literals.",
+        "expected_output": "true\nfalse\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 20;
+                print(x == y);
+                print(x != y);
+                return 0;
+            }
+        """,
+        "description": "Equality and inequality operators.",
+        "expected_output": "false\ntrue\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 10;
+                print(x == y);
+                print(x != y);
+                return 0;
+            }
+        """,
+        "description": "Equality and inequality operators with equal values.",
+        "expected_output": "true\nfalse\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 5;
+                print(x > y);
+                print(x < y);
+                print(x >= y);
+                print(x <= y);
+                print(x >= 10);
+                print(x <= 10);
+                return 0;
+            }
+        """,
+        "description": "Relational operators.",
+        "expected_output": "true\nfalse\ntrue\nfalse\ntrue\ntrue\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 2;
+                int z = 3;
+                print(x / y * z);
+                print(x * y / z);
+                print(x + y * z);
+                return 0;
+            }
+        """,
+        "description": "Operator precedence.",
+        "expected_output": "15\n6\n16\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = true;
+                return 0;
+            }
+        """,
+        "description": "Static Type error: Type mismatch in variable declaration.",
+        "expected_output": "Error: Type Error: Type mismatch in variable declaration for 'x': expected int, got bool. at line 4, column 25\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                if (10) {
+                    print("true");
+                }
+                return 0;
+            }
+        """,
+        "description": "Static Type error: Non-boolean condition in if statement.",
+        "expected_output": "Error: Type Error: If condition must be of type 'bool'. at line 4, column 20\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                string s = "hello";
+                print(x == s);
+                return 0;
+            }
+        """,
+        "description": "Static Type error: Incompatible types for equality comparison.",
+        "expected_output": "Error: Type Error: Incompatible types for equality comparison '==': int and string. at line 5, column 27\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                bool b = true;
+                print(x < b);
+                return 0;
+            }
+        """,
+        "description": "Static Type error: Incompatible types for relational comparison.",
+        "expected_output": "Error: Type Error: Comparison operator '<' only supported for integers, got int and bool. at line 5, column 25\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int global_var = 10;
+            int main() {
+                print(global_var);
+                return 0;
+            }
+        """,
+        "description": "Global variable declaration and access.",
+        "expected_output": "10\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 20;
+                print(x + y);
+            }
+        """,
+        "description": "Missing return statement in int main().",
+        "expected_output": "Error: Runtime Error: Function 'main' declared to return 'int' but returned nothing. at line 3, column 17\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            void foo() {
+                print("Hello");
+            }
+            int main() {
+                foo();
+                return 0;
+            }
+        """,
+        "description": "Void function call as statement.",
+        "expected_output": "Hello\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                {
+                    int y = 20;
+                    print(x + y);
+                }
+                // print(y); // This would be a static type error (undeclared)
+                return 0;
+            }
+        """,
+        "description": "Nested block scope with outer variable access.",
+        "expected_output": "30\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 20;
+                if (x < y) {
+                    int z = x + y;
+                    print(z);
+                } else {
+                    int w = x - y;
+                    print(w);
+                }
+                return 0;
+            }
+        """,
+        "description": "Variable declaration within if-else blocks.",
+        "expected_output": "30\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                while (x > 0) {
+                    int y = x;
+                    print(y);
+                    x = x - 5;
+                }
+                return 0;
+            }
+        """,
+        "description": "Variable declaration within while loop.",
+        "expected_output": "10\n5\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                {
+                    string x = "hello"; // Redeclaration in inner scope is allowed (shadowing)
+                    print(x);
+                }
+                print(x); // Outer x
+                return 0;
+            }
+        """,
+        "description": "Shadowing variable in inner block.",
+        "expected_output": "hello\n10\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                x = !x; // Type mismatch
+                return 0;
+            }
+        """,
+        "description": "Static Type error: Type mismatch with unary operator.",
+        "expected_output": "Error: Type Error: Type mismatch in assignment for 'x': expected int, got bool. at line 5, column 21\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x;
+                x = 10; // Assignment to uninitialized variable
+                print(x);
+                return 0;
+            }
+        """,
+        "description": "Variable declaration without initialization, then assignment.",
+        "expected_output": "10\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 20;
+                int z = (x + y) * 2;
+                print(z);
+                return 0;
+            }
+        """,
+        "description": "Complex expression with multiple operators and parentheses.",
+        "expected_output": "60\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int a = 1;
+            int b = 2;
+            int c = 3;
+            int main() {
+                print(a + b * c); // 1 + (2 * 3) = 7
+                print((a + b) * c); // (1 + 2) * 3 = 9
+                return 0;
+            }
+        """,
+        "description": "Operator precedence and associativity.",
+        "expected_output": "7\n9\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 0;
+                while (x > 0 && y < 5) {
+                    print(x);
+                    x = x - 1;
+                    y = y + 1;
+                }
+                return 0;
+            }
+        """,
+        "description": "While loop with complex logical condition.",
+        "expected_output": "10\n9\n8\n7\n6\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                for (int i = 0; i < x; i = i + 1) {
+                    if (i % 2 == 0) {
+                        print(i);
+                    }
+                }
+                return 0;
+            }
+        """,
+        "description": "For loop with nested if and modulo operator.",
+        "expected_output": "0\n2\n4\n6\n8\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                string s1 = "hello";
+                string s2 = "world";
+                print(s1 + s2);
+                print(s1 == s2);
+                print(s1 != s2);
+                return 0;
+            }
+        """,
+        "description": "String concatenation and comparison.",
+        "expected_output": "helloworld\nfalse\ntrue\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                bool b1 = true;
+                bool b2 = false;
+                print(b1 && b2);
+                print(b1 || b2);
+                print(!b1);
+                return 0;
+            }
+        """,
+        "description": "Boolean logical operations.",
+        "expected_output": "false\ntrue\nfalse\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                void y; // Cannot declare void variable
+                return 0;
+            }
+        """,
+        "description": "Static Type error: Declaring a void variable.",
+        "expected_output": "Error: Type Error: Cannot declare variable of type 'void'. at line 5, column 17\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 20;
+                int z = 30;
+                if (x < y) {
+                    print(z);
+                }
+                return 0;
+            }
+        """,
+        "description": "Simple if statement.",
+        "expected_output": "30\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 20;
+                int z = 30;
+                if (x > y) {
+                    print(z);
+                } else {
+                    print(y);
+                }
+                return 0;
+            }
+        """,
+        "description": "Simple if-else statement.",
+        "expected_output": "20\n",
+        "inputs": []
+    },
+    {
+        "code": """
+            int main() {
+                int x = 10;
+                int y = 20;
+                int z = 30;
+                if (x > y) {
+                    print(z);
+                } else if (x == 10) {
+                    print(x);
+                } else {
+                    print(y);
+                }
+                return 0;
+            }
+        """,
+        "description": "If-else if-else statement.",
+        "expected_output": "10\n",
+        "inputs": []
+    },
+]
+
+# --- Test Runner ---
+def run_tests():
+    total_tests = len(TEST_PROGRAMS)
+    passed_tests = 0
+    results = []
+
+    print(f"Running {total_tests} tests...")
+
+    for i, test_case in enumerate(TEST_PROGRAMS):
+        code = test_case["code"]
+        description = test_case["description"]
+        expected_output = test_case["expected_output"]
+        inputs = test_case.get("inputs", [])
+
+        actual_output = ""
+        try:
+            actual_output = interpreter_main(code, inputs)
+            if actual_output == expected_output:
+                status = "PASS"
+                passed_tests += 1
+            else:
+                status = "FAIL"
+        except Exception as e:
+            status = "ERROR"
+            actual_output = f"Interpreter crashed: {e}\n"
+
+        results.append({"description": description, "status": status, "actual_output": actual_output, "expected_output": expected_output})
+
+    print("\n--- Test Summary ---")
+    for res in results:
+        print(f"[{res['status']}] {res['description']}")
+        if res['status'] != 'PASS':
+            print(f"  Expected:\n{res['expected_output'].strip()}")
+            print(f"  Actual:\n{res['actual_output'].strip()}")
+
+    print(f"\nTotal Tests: {total_tests}, Passed: {passed_tests}, Failed: {total_tests - passed_tests}")
+    return passed_tests == total_tests
+
+# --- Command Line Interface ---
+def main():
+    parser = argparse.ArgumentParser(description="A C-like language interpreter.")
+    parser.add_argument("file", nargs='?', help="Path to the program file to execute.")
+    parser.add_argument("--test", action="store_true", help="Run embedded test suite.")
+    parser.add_argument("--syntax", action="store_true", help="Print language syntax documentation.")
+
+    args = parser.parse_args()
+
+    if args.syntax:
+        print(LANGUAGE_SPECIFICATION)
+        sys.exit(0)
+
+    if args.test:
+        success = run_tests()
+        sys.exit(0 if success else 1)
+
+    if args.file:
+        try:
+            with open(args.file, 'r') as f:
+                program_code = f.read()
+            output = interpreter_main(program_code)
+            sys.stdout.write(output)
+        except FileNotFoundError:
+            print(f"Error: File not found: {args.file}")
+            sys.exit(1)
+        except Exception as e:
+            print(f"Error executing program: {e}")
+            sys.exit(1)
+    else:
+        parser.print_help()
+        sys.exit(1)
+
+if __name__ == "__main__":
+    main()
